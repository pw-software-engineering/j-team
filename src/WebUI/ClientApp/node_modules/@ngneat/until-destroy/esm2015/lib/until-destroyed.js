import { takeUntil } from 'rxjs/operators';
import { DECORATOR_APPLIED, getSymbol, isFunction, createSubjectOnTheInstance, completeSubjectOnTheInstance } from './internals';
function overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol) {
    const originalDestroy = instance[destroyMethodName];
    if (ngDevMode && isFunction(originalDestroy) === false) {
        throw new Error(`${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`);
    }
    createSubjectOnTheInstance(instance, symbol);
    instance[destroyMethodName] = function () {
        originalDestroy.apply(this, arguments);
        completeSubjectOnTheInstance(this, symbol);
        // We have to re-assign this property back to the original value.
        // If the `untilDestroyed` operator is called for the same instance
        // multiple times, then we will be able to get the original
        // method again and not the patched one.
        instance[destroyMethodName] = originalDestroy;
    };
}
export function untilDestroyed(instance, destroyMethodName) {
    return (source) => {
        const symbol = getSymbol(destroyMethodName);
        // If `destroyMethodName` is passed then the developer applies
        // this operator to something non-related to Angular DI system
        if (typeof destroyMethodName === 'string') {
            overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);
        }
        else {
            ngDevMode && ensureClassIsDecorated(instance);
            createSubjectOnTheInstance(instance, symbol);
        }
        return source.pipe(takeUntil(instance[symbol]));
    };
}
function ensureClassIsDecorated(instance) {
    const prototype = Object.getPrototypeOf(instance);
    const missingDecorator = !(DECORATOR_APPLIED in prototype);
    if (missingDecorator) {
        throw new Error('untilDestroyed operator cannot be used inside directives or ' +
            'components or providers that are not decorated with UntilDestroy decorator');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW50aWwtZGVzdHJveWVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi91bnRpbC1kZXN0cm95ZWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNDLE9BQU8sRUFDTCxpQkFBaUIsRUFDakIsU0FBUyxFQUNULFVBQVUsRUFDViwwQkFBMEIsRUFDMUIsNEJBQTRCLEVBQzdCLE1BQU0sYUFBYSxDQUFDO0FBTXJCLFNBQVMsa0NBQWtDLENBQ3pDLFFBQWEsRUFDYixpQkFBeUIsRUFDekIsTUFBYztJQUVkLE1BQU0sZUFBZSxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBRXBELElBQUksU0FBUyxJQUFJLFVBQVUsQ0FBQyxlQUFlLENBQUMsS0FBSyxLQUFLLEVBQUU7UUFDdEQsTUFBTSxJQUFJLEtBQUssQ0FDYixHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUMsSUFBSSxrREFBa0QsaUJBQWlCLEVBQUUsQ0FDbEcsQ0FBQztLQUNIO0lBRUQsMEJBQTBCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBRTdDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHO1FBQzVCLGVBQWUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZDLDRCQUE0QixDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUMzQyxpRUFBaUU7UUFDakUsbUVBQW1FO1FBQ25FLDJEQUEyRDtRQUMzRCx3Q0FBd0M7UUFDeEMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsZUFBZSxDQUFDO0lBQ2hELENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLFVBQVUsY0FBYyxDQUFJLFFBQVcsRUFBRSxpQkFBMkI7SUFDeEUsT0FBTyxDQUFJLE1BQXFCLEVBQUUsRUFBRTtRQUNsQyxNQUFNLE1BQU0sR0FBRyxTQUFTLENBQUksaUJBQWlCLENBQUMsQ0FBQztRQUUvQyw4REFBOEQ7UUFDOUQsOERBQThEO1FBQzlELElBQUksT0FBTyxpQkFBaUIsS0FBSyxRQUFRLEVBQUU7WUFDekMsa0NBQWtDLENBQUMsUUFBUSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3pFO2FBQU07WUFDTCxTQUFTLElBQUksc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDOUMsMEJBQTBCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQzlDO1FBRUQsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBSyxRQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5RCxDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBUyxzQkFBc0IsQ0FBQyxRQUEyQjtJQUN6RCxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2xELE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixJQUFJLFNBQVMsQ0FBQyxDQUFDO0lBRTNELElBQUksZ0JBQWdCLEVBQUU7UUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FDYiw4REFBOEQ7WUFDNUQsNEVBQTRFLENBQy9FLENBQUM7S0FDSDtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7XG4gIERFQ09SQVRPUl9BUFBMSUVELFxuICBnZXRTeW1ib2wsXG4gIGlzRnVuY3Rpb24sXG4gIGNyZWF0ZVN1YmplY3RPblRoZUluc3RhbmNlLFxuICBjb21wbGV0ZVN1YmplY3RPblRoZUluc3RhbmNlXG59IGZyb20gJy4vaW50ZXJuYWxzJztcblxuLy8gVGhpcyB3aWxsIGJlIHByb3ZpZGVkIHRocm91Z2ggVGVyc2VyIGdsb2JhbCBkZWZpbml0aW9ucyBieSBBbmd1bGFyIENMSS4gVGhpcyB3aWxsXG4vLyBoZWxwIHRvIHRyZWUtc2hha2UgYXdheSB0aGUgY29kZSB1bm5lZWRlZCBmb3IgcHJvZHVjdGlvbiBidW5kbGVzLlxuZGVjbGFyZSBjb25zdCBuZ0Rldk1vZGU6IGJvb2xlYW47XG5cbmZ1bmN0aW9uIG92ZXJyaWRlTm9uRGlyZWN0aXZlSW5zdGFuY2VNZXRob2QoXG4gIGluc3RhbmNlOiBhbnksXG4gIGRlc3Ryb3lNZXRob2ROYW1lOiBzdHJpbmcsXG4gIHN5bWJvbDogc3ltYm9sXG4pOiB2b2lkIHtcbiAgY29uc3Qgb3JpZ2luYWxEZXN0cm95ID0gaW5zdGFuY2VbZGVzdHJveU1ldGhvZE5hbWVdO1xuXG4gIGlmIChuZ0Rldk1vZGUgJiYgaXNGdW5jdGlvbihvcmlnaW5hbERlc3Ryb3kpID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAke2luc3RhbmNlLmNvbnN0cnVjdG9yLm5hbWV9IGlzIHVzaW5nIHVudGlsRGVzdHJveWVkIGJ1dCBkb2Vzbid0IGltcGxlbWVudCAke2Rlc3Ryb3lNZXRob2ROYW1lfWBcbiAgICApO1xuICB9XG5cbiAgY3JlYXRlU3ViamVjdE9uVGhlSW5zdGFuY2UoaW5zdGFuY2UsIHN5bWJvbCk7XG5cbiAgaW5zdGFuY2VbZGVzdHJveU1ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgb3JpZ2luYWxEZXN0cm95LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgY29tcGxldGVTdWJqZWN0T25UaGVJbnN0YW5jZSh0aGlzLCBzeW1ib2wpO1xuICAgIC8vIFdlIGhhdmUgdG8gcmUtYXNzaWduIHRoaXMgcHJvcGVydHkgYmFjayB0byB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgLy8gSWYgdGhlIGB1bnRpbERlc3Ryb3llZGAgb3BlcmF0b3IgaXMgY2FsbGVkIGZvciB0aGUgc2FtZSBpbnN0YW5jZVxuICAgIC8vIG11bHRpcGxlIHRpbWVzLCB0aGVuIHdlIHdpbGwgYmUgYWJsZSB0byBnZXQgdGhlIG9yaWdpbmFsXG4gICAgLy8gbWV0aG9kIGFnYWluIGFuZCBub3QgdGhlIHBhdGNoZWQgb25lLlxuICAgIGluc3RhbmNlW2Rlc3Ryb3lNZXRob2ROYW1lXSA9IG9yaWdpbmFsRGVzdHJveTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVudGlsRGVzdHJveWVkPFQ+KGluc3RhbmNlOiBULCBkZXN0cm95TWV0aG9kTmFtZT86IGtleW9mIFQpIHtcbiAgcmV0dXJuIDxVPihzb3VyY2U6IE9ic2VydmFibGU8VT4pID0+IHtcbiAgICBjb25zdCBzeW1ib2wgPSBnZXRTeW1ib2w8VD4oZGVzdHJveU1ldGhvZE5hbWUpO1xuXG4gICAgLy8gSWYgYGRlc3Ryb3lNZXRob2ROYW1lYCBpcyBwYXNzZWQgdGhlbiB0aGUgZGV2ZWxvcGVyIGFwcGxpZXNcbiAgICAvLyB0aGlzIG9wZXJhdG9yIHRvIHNvbWV0aGluZyBub24tcmVsYXRlZCB0byBBbmd1bGFyIERJIHN5c3RlbVxuICAgIGlmICh0eXBlb2YgZGVzdHJveU1ldGhvZE5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvdmVycmlkZU5vbkRpcmVjdGl2ZUluc3RhbmNlTWV0aG9kKGluc3RhbmNlLCBkZXN0cm95TWV0aG9kTmFtZSwgc3ltYm9sKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmdEZXZNb2RlICYmIGVuc3VyZUNsYXNzSXNEZWNvcmF0ZWQoaW5zdGFuY2UpO1xuICAgICAgY3JlYXRlU3ViamVjdE9uVGhlSW5zdGFuY2UoaW5zdGFuY2UsIHN5bWJvbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKHRha2VVbnRpbDxVPigoaW5zdGFuY2UgYXMgYW55KVtzeW1ib2xdKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUNsYXNzSXNEZWNvcmF0ZWQoaW5zdGFuY2U6IEluc3RhbmNlVHlwZTxhbnk+KTogbmV2ZXIgfCB2b2lkIHtcbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGluc3RhbmNlKTtcbiAgY29uc3QgbWlzc2luZ0RlY29yYXRvciA9ICEoREVDT1JBVE9SX0FQUExJRUQgaW4gcHJvdG90eXBlKTtcblxuICBpZiAobWlzc2luZ0RlY29yYXRvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICd1bnRpbERlc3Ryb3llZCBvcGVyYXRvciBjYW5ub3QgYmUgdXNlZCBpbnNpZGUgZGlyZWN0aXZlcyBvciAnICtcbiAgICAgICAgJ2NvbXBvbmVudHMgb3IgcHJvdmlkZXJzIHRoYXQgYXJlIG5vdCBkZWNvcmF0ZWQgd2l0aCBVbnRpbERlc3Ryb3kgZGVjb3JhdG9yJ1xuICAgICk7XG4gIH1cbn1cbiJdfQ==