import { Subject } from 'rxjs';
export function isFunction(target) {
    return typeof target === 'function';
}
/**
 * Applied to instances and stores `Subject` instance when
 * no custom destroy method is provided.
 */
const DESTROY = Symbol('__destroy');
/**
 * Applied to definitions and informs that class is decorated
 */
export const DECORATOR_APPLIED = Symbol('__decoratorApplied');
/**
 * If we use the `untilDestroyed` operator multiple times inside the single
 * instance providing different `destroyMethodName`, then all streams will
 * subscribe to the single subject. If any method is invoked, the subject will
 * emit and all streams will be unsubscribed. We wan't to prevent this behavior,
 * thus we store subjects under different symbols.
 */
export function getSymbol(destroyMethodName) {
    if (typeof destroyMethodName === 'string') {
        return Symbol(`__destroy__${destroyMethodName}`);
    }
    else {
        return DESTROY;
    }
}
export function markAsDecorated(type) {
    // Store this property on the prototype if it's an injectable class, component or directive.
    // We will be able to handle class extension this way.
    type.prototype[DECORATOR_APPLIED] = true;
}
export function createSubjectOnTheInstance(instance, symbol) {
    if (!instance[symbol]) {
        instance[symbol] = new Subject();
    }
}
export function completeSubjectOnTheInstance(instance, symbol) {
    if (instance[symbol]) {
        instance[symbol].next();
        instance[symbol].complete();
        // We also have to re-assign this property thus in the future
        // we will be able to create new subject on the same instance.
        instance[symbol] = null;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9pbnRlcm5hbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUkvQixNQUFNLFVBQVUsVUFBVSxDQUFDLE1BQWU7SUFDeEMsT0FBTyxPQUFPLE1BQU0sS0FBSyxVQUFVLENBQUM7QUFDdEMsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sT0FBTyxHQUFrQixNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7QUFFbkQ7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSxpQkFBaUIsR0FBa0IsTUFBTSxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFFN0U7Ozs7OztHQU1HO0FBQ0gsTUFBTSxVQUFVLFNBQVMsQ0FBSSxpQkFBMkI7SUFDdEQsSUFBSSxPQUFPLGlCQUFpQixLQUFLLFFBQVEsRUFBRTtRQUN6QyxPQUFPLE1BQU0sQ0FBQyxjQUFjLGlCQUFpQixFQUFFLENBQUMsQ0FBQztLQUNsRDtTQUFNO1FBQ0wsT0FBTyxPQUFPLENBQUM7S0FDaEI7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVLGVBQWUsQ0FDN0IsSUFBNkU7SUFFN0UsNEZBQTRGO0lBQzVGLHNEQUFzRDtJQUN0RCxJQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQzNDLENBQUM7QUFRRCxNQUFNLFVBQVUsMEJBQTBCLENBQUMsUUFBYSxFQUFFLE1BQWM7SUFDdEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUNyQixRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztLQUN4QztBQUNILENBQUM7QUFFRCxNQUFNLFVBQVUsNEJBQTRCLENBQUMsUUFBYSxFQUFFLE1BQWM7SUFDeEUsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDcEIsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3hCLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUM1Qiw2REFBNkQ7UUFDN0QsOERBQThEO1FBQzlELFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUM7S0FDekI7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZVR5cGUsIMm1RGlyZWN0aXZlVHlwZSwgybVDb21wb25lbnRUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFBpcGVUeXBlIH0gZnJvbSAnLi9pdnknO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih0YXJnZXQ6IHVua25vd24pIHtcbiAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQXBwbGllZCB0byBpbnN0YW5jZXMgYW5kIHN0b3JlcyBgU3ViamVjdGAgaW5zdGFuY2Ugd2hlblxuICogbm8gY3VzdG9tIGRlc3Ryb3kgbWV0aG9kIGlzIHByb3ZpZGVkLlxuICovXG5jb25zdCBERVNUUk9ZOiB1bmlxdWUgc3ltYm9sID0gU3ltYm9sKCdfX2Rlc3Ryb3knKTtcblxuLyoqXG4gKiBBcHBsaWVkIHRvIGRlZmluaXRpb25zIGFuZCBpbmZvcm1zIHRoYXQgY2xhc3MgaXMgZGVjb3JhdGVkXG4gKi9cbmV4cG9ydCBjb25zdCBERUNPUkFUT1JfQVBQTElFRDogdW5pcXVlIHN5bWJvbCA9IFN5bWJvbCgnX19kZWNvcmF0b3JBcHBsaWVkJyk7XG5cbi8qKlxuICogSWYgd2UgdXNlIHRoZSBgdW50aWxEZXN0cm95ZWRgIG9wZXJhdG9yIG11bHRpcGxlIHRpbWVzIGluc2lkZSB0aGUgc2luZ2xlXG4gKiBpbnN0YW5jZSBwcm92aWRpbmcgZGlmZmVyZW50IGBkZXN0cm95TWV0aG9kTmFtZWAsIHRoZW4gYWxsIHN0cmVhbXMgd2lsbFxuICogc3Vic2NyaWJlIHRvIHRoZSBzaW5nbGUgc3ViamVjdC4gSWYgYW55IG1ldGhvZCBpcyBpbnZva2VkLCB0aGUgc3ViamVjdCB3aWxsXG4gKiBlbWl0IGFuZCBhbGwgc3RyZWFtcyB3aWxsIGJlIHVuc3Vic2NyaWJlZC4gV2Ugd2FuJ3QgdG8gcHJldmVudCB0aGlzIGJlaGF2aW9yLFxuICogdGh1cyB3ZSBzdG9yZSBzdWJqZWN0cyB1bmRlciBkaWZmZXJlbnQgc3ltYm9scy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN5bWJvbDxUPihkZXN0cm95TWV0aG9kTmFtZT86IGtleW9mIFQpOiBzeW1ib2wge1xuICBpZiAodHlwZW9mIGRlc3Ryb3lNZXRob2ROYW1lID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBTeW1ib2woYF9fZGVzdHJveV9fJHtkZXN0cm95TWV0aG9kTmFtZX1gKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gREVTVFJPWTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFya0FzRGVjb3JhdGVkPFQ+KFxuICB0eXBlOiBJbmplY3RhYmxlVHlwZTxUPiB8IFBpcGVUeXBlPFQ+IHwgybVEaXJlY3RpdmVUeXBlPFQ+IHwgybVDb21wb25lbnRUeXBlPFQ+XG4pOiB2b2lkIHtcbiAgLy8gU3RvcmUgdGhpcyBwcm9wZXJ0eSBvbiB0aGUgcHJvdG90eXBlIGlmIGl0J3MgYW4gaW5qZWN0YWJsZSBjbGFzcywgY29tcG9uZW50IG9yIGRpcmVjdGl2ZS5cbiAgLy8gV2Ugd2lsbCBiZSBhYmxlIHRvIGhhbmRsZSBjbGFzcyBleHRlbnNpb24gdGhpcyB3YXkuXG4gIHR5cGUucHJvdG90eXBlW0RFQ09SQVRPUl9BUFBMSUVEXSA9IHRydWU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVW50aWxEZXN0cm95T3B0aW9ucyB7XG4gIGJsYWNrTGlzdD86IHN0cmluZ1tdO1xuICBhcnJheU5hbWU/OiBzdHJpbmc7XG4gIGNoZWNrUHJvcGVydGllcz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdWJqZWN0T25UaGVJbnN0YW5jZShpbnN0YW5jZTogYW55LCBzeW1ib2w6IHN5bWJvbCk6IHZvaWQge1xuICBpZiAoIWluc3RhbmNlW3N5bWJvbF0pIHtcbiAgICBpbnN0YW5jZVtzeW1ib2xdID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGxldGVTdWJqZWN0T25UaGVJbnN0YW5jZShpbnN0YW5jZTogYW55LCBzeW1ib2w6IHN5bWJvbCk6IHZvaWQge1xuICBpZiAoaW5zdGFuY2Vbc3ltYm9sXSkge1xuICAgIGluc3RhbmNlW3N5bWJvbF0ubmV4dCgpO1xuICAgIGluc3RhbmNlW3N5bWJvbF0uY29tcGxldGUoKTtcbiAgICAvLyBXZSBhbHNvIGhhdmUgdG8gcmUtYXNzaWduIHRoaXMgcHJvcGVydHkgdGh1cyBpbiB0aGUgZnV0dXJlXG4gICAgLy8gd2Ugd2lsbCBiZSBhYmxlIHRvIGNyZWF0ZSBuZXcgc3ViamVjdCBvbiB0aGUgc2FtZSBpbnN0YW5jZS5cbiAgICBpbnN0YW5jZVtzeW1ib2xdID0gbnVsbDtcbiAgfVxufVxuIl19